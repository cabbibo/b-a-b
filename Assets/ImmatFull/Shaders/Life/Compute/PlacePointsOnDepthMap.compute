// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PlaceOnDepth

struct Vert{
  float3 pos;
  float3 oPos;
  float3 nor;
  float3 tangent;
  float2 uv;
  float life;
  float debug;
};

RWStructuredBuffer<Vert> _VertBuffer;
int _VertBuffer_COUNT;


int safeID( int id , int max ){
    return clamp( id , 0 , max );
}

float hash( float n ){
        return frac(sin(n)*43758.5453);
      }

      

float4x4 _CameraViewMatrix;
float4x4 _CameraViewMatrixInverse;
float4x4 _CameraProjectionMatrix;
float4x4 _CameraProjectionMatrixInverse;

float3 _CameraPosition;



Texture2D<float4> _HeightMap;
SamplerState sampler_HeightMap;
float3 _MapSize;

float3 terrainPos( float3 pos ){
  return float3( pos.x , _HeightMap.SampleLevel(sampler_HeightMap, (((pos.xz+_MapSize.xz/2)) / _MapSize.xz) , 1).x * _MapSize.y * 2, pos.z);
}


float terrainHeight( float3 pos ){
   float h =  _HeightMap.SampleLevel(sampler_HeightMap, (((pos.xz+_MapSize.xz/2)) / _MapSize.xz) , 1).x * _MapSize.y * 2;
   return pos.y - h;
}

float3 normalizedTerrainPos( float3 pos ){
  
return float3(((pos.x+_MapSize.x/2) / _MapSize.x) , pos.y / _MapSize.y ,  (pos.z+_MapSize.z/2) / _MapSize.z);

}

void GetTerrainData( float3 pos , out float3  fPos, out float3 fNor){

    float3 eps = float3(1.1,0,0);
    fPos = terrainPos( pos );

    float3 l = terrainPos( pos + eps.xyy);
    float3 r = terrainPos( pos - eps.xyy);
    float3 u = terrainPos( pos + eps.yyx);
    float3 d = terrainPos( pos - eps.yyx);

    fNor = -normalize(cross(l-r,u-d));

}

float3 TraceTerrain(float3 ro, float3 rd , out float3 nor){
    float3 pos;
    float3 fPos;
    float3 fNor;
    float hit = 0;
    float d = 0;

    for( float i = 0; i < 200; i++ ){
        d = (i / 200) * 300;
        pos = ro + rd * d;

        float h = terrainHeight( pos);

        if( h < 0 )
        

        // TODO linearly interpolate
        if( h < 0 ){ 
            hit = 1;
            GetTerrainData( pos , fPos , fNor);
            nor = fNor;
            break;  
        }

    
    }

    return fPos;

}


#include "UnityCG.cginc"
 


Texture2D<float4> _DepthTexture;
SamplerState sampler_DepthTexture;

float _CameraNear;
float _CameraFar;



float getDepth( float2 screenCoords ){
  
    float depth = _DepthTexture.SampleLevel(sampler_DepthTexture, screenCoords, 0).r;

    depth = LinearEyeDepth(depth);//depth * (_CameraFar - _CameraNear) + _CameraNear;
    return depth;
}

float getLinearDepth( float2 screenCoords ){
  
    float depth = _DepthTexture.SampleLevel(sampler_DepthTexture, screenCoords, 0).r;

    depth = Linear01Depth(depth);//depth * (_CameraFar - _CameraNear) + _CameraNear;
    return depth;
}

/*float2 Hash2D(float p)
{
    float2 p2 = frac(p * float2(5.3983, 5.4427));
    p2 += dot(p2.yx, p2.xy + 19.19);
    return frac(p2.xx * p2.yy);
}*/

float hash11(float p)
{
    p = frac(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return frac(p);
}

float2 hash21(float p)
{
	float3 p3 = frac(p * float3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.xx+p3.yz)*p3.zy);

}



float2 Hash2D(float p)
{
    float2 p2 = frac(sin(float2(p, p + 1.0)) * 43758.5453);
    return p2;
}

float3 TraceTerrainBinary(float3 ro, float3 rd , out float3 nor){
    float3 pos;
    float3 fPos;
    float3 fNor;
    float hit = 0;
    float d = 0;

    float3 intersectionPoint = ro;
    float stepSize = 2;

    float hasHit = 0;
    for( float i = 0; i < 150; i++ ){
      
        float h = terrainHeight( intersectionPoint );

        if( h < 0 ){
          hasHit= 1;
          stepSize *= .5;
          intersectionPoint -= rd * stepSize;
        }else{
          intersectionPoint += rd * stepSize;
        }
        

    
    }

    GetTerrainData( intersectionPoint , fPos , nor);
    if( hasHit == 0 ){
      nor = float3(0,1,0);
    }

    return intersectionPoint;

}


float4 ComputeClipSpacePosition(float2 positionNDC, float deviceDepth)
{
    float4 positionCS = float4(positionNDC * 2.0 - 1.0, deviceDepth, 1.0);

//#if UNITY_UV_STARTS_AT_TOP
    // Our world space, view space, screen space and NDC space are Y-up.
    // Our clip space is flipped upside-down due to poor legacy Unity design.
    // The flip is baked into the projection matrix, so we only have to flip
    // manually when going from CS to NDC and back.
    positionCS.y = -positionCS.y;
//#endif

    return positionCS;
}

float3 ComputeViewSpacePosition(float2 positionNDC, float deviceDepth, float4x4 invProjMatrix)
{
    float4 positionCS = ComputeClipSpacePosition(positionNDC, deviceDepth);
    float4 positionVS = mul(invProjMatrix, positionCS);
    // The view space uses a right-handed coordinate system.
    positionVS.z = -positionVS.z;
    return positionVS.xyz / positionVS.w;
}


float4x4 _CameraViewProjectionMatrixInverse;
float3 ComputeWorldSpacePosition(float2 positionNDC, float deviceDepth, float4x4 invViewProjMatrix)
{
    float4 positionCS  = ComputeClipSpacePosition(positionNDC, deviceDepth);
    float4 hpositionWS = mul(invViewProjMatrix, positionCS);
    return hpositionWS.xyz / hpositionWS.w;
}


 
// depth to linear 0-1
void Linear01Depth_float(float InDepth, float NearClip, float FarClip, out float OutDepth){
 
    float x, y, z, w;
        x = (float)((FarClip-NearClip)/NearClip);
        y = 1.0f;
        z = (float)(FarClip-NearClip)/(NearClip*FarClip);
        w = (float)(1.0f / FarClip);
  OutDepth = 1 / (1.0 / (x * InDepth + y)); //
}


float3 getWorldPos( float2 coordinates ){

    float depthSample = _DepthTexture.SampleLevel(sampler_DepthTexture,coordinates, 0).r;
    float4 clipSpace2 = float4(coordinates * 2.0 - 1.0, (1-depthSample) * 2 -1 , 1.0);
    float4 viewSpace = mul(_CameraProjectionMatrixInverse,clipSpace2);
    viewSpace /= viewSpace.w;



    float4 worldPos = mul(_CameraViewMatrixInverse, viewSpace);

    return worldPos.xyz;


}
 

#define NR_THREADS 128
[numthreads(NR_THREADS,1,1)]
void PlaceOnDepth (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID) {

  int pID = threadID + u3GroupID.x * NR_THREADS;


    if(pID < _VertBuffer_COUNT){ 

    int sID = safeID( pID, _VertBuffer_COUNT );
        Vert v = _VertBuffer[sID];
              // gets our current screen space position
    float4 currentViewPosition =mul( _CameraViewMatrix , float4(v.pos, 1.0));
    float4 currentScreenSpacePosition =mul( _CameraProjectionMatrix , currentViewPosition);
    currentScreenSpacePosition /= currentScreenSpacePosition.w;

    currentScreenSpacePosition /= 2.;
    currentScreenSpacePosition += .5;




 if( v.life < 0 || currentScreenSpacePosition.x < 0 || currentScreenSpacePosition.x > 1 || currentScreenSpacePosition.y < 0 || currentScreenSpacePosition.y > 1){

    float2 coordinates = hash21( float(pID * 121) + _Time + float(pID * 22) );
    coordinates += hash21( float(pID * 41) + _Time + float(pID * 4) );

    coordinates /= 2;
  
      // uses project matrix to project forward
    float4 viewSpacePosition = mul(_CameraProjectionMatrixInverse , float4(coordinates * 2.0 - 1.0, 1.0, 1.0));
    viewSpacePosition /= viewSpacePosition.w;

    viewSpacePosition.xyz *= (-1 / viewSpacePosition.z);

    float3 worldPosition = mul(_CameraViewMatrixInverse ,viewSpacePosition).xyz;

    float3 ro = worldPosition.xyz;
    float3 rd = worldPosition.xyz - _CameraPosition; 
  float3 nor;
    float3 fPos = TraceTerrainBinary( ro , rd , nor );
    v.pos = fPos;
    v.nor = nor;

    float depthLinear = getLinearDepth( coordinates );
    float4 ndc = float4(coordinates, depthLinear, 1.0);


    float linearDepth = 0;
    float depthSample = _DepthTexture.SampleLevel(sampler_DepthTexture,coordinates, 0).r;
    Linear01Depth_float( depthSample , _CameraNear, _CameraFar,linearDepth);
    // Convert NDC to clip space
    //float4 clipSpace = ndc * 2.0 - 1.0;
    float4 clipSpace2 = float4(coordinates * 2.0 - 1.0, (1-depthSample) * 2 -1 , 1.0);
    float4 viewSpace = mul(_CameraProjectionMatrixInverse,clipSpace2);
    viewSpace /= viewSpace.w;



    float4 worldPos = mul(_CameraViewMatrixInverse, viewSpace);

    v.pos = getWorldPos( coordinates );//worldPos.xyz;

    float3 dX = getWorldPos( coordinates + float2(.001,0) ) -  getWorldPos( coordinates - float2(.001,0) );
    float3 dY = getWorldPos( coordinates + float2(0,.001) ) - getWorldPos( coordinates - float2(0,.001) );

    v.nor = -normalize(cross(dX*100 ,dY*100));//normalize(cross(dX*100,dY*100));

    v.pos += v.nor * .1;
    //v.nor = float3(1,0,0);

   // v.pos = _CameraPosition + normalize(rd) * depthLinear* 1;
/*
    float depthLinear = getLinearDepth( coordinates );
 float4 ndc = float4(coordinates, depthLinear, 1.0);
   // Convert NDC to clip space
    float4 clipSpace = ndc * 2.0 - 1.0;
   float4 viewSpace = mul(_CameraProjectionMatrixInverse, clipSpace);
    viewSpace /= viewSpace.w;
    
    // Convert view space to world space
    float4 worldPos = mul(_CameraViewMatrixInverse, viewSpace);

    // Adjust depth
    worldPos.xyz *= lerp(_CameraNear, _CameraFar, depthLinear);

    float depth = getDepth(coordinates);
    fPos = _CameraPosition + normalize(rd) * depth;
    v.pos = fPos;
    //v.debug.y = _Time;

 float depth2 = _DepthTexture.SampleLevel(sampler_DepthTexture, coordinates, 0).r;

    float3 worldSpace = ComputeWorldSpacePosition( coordinates , depth2 , _CameraProjectionMatrixInverse* _CameraViewMatrixInverse);
  v.pos = _CameraPosition + Linear01Depth(depth2) * normalize(rd) * 10;

  







  //float3 viewSpace = ComputeViewSpacePosition( coordinates , depth2 , _CameraProjectionMatrixInverse);

  //v.pos = mul(_CameraViewMatrixInverse , float4(viewSpace, 1.0)).xyz;

  v.pos = worldPos.xyz;

  */

    //v.pos = _CameraPosition + normalize(rd) * (1-depth2) * (_CameraFar-_CameraNear) - _CameraFar * normalize(rd);// worldSpace;
   // v.pos = coordinates.x *_MapSize.x * float3(1,0,0) + coordinates.y * _MapSize.z * float3(0,0,1);

    //v.pos = terrainPos(v.pos);
    
    //float3 terrainPos( float3 pos ){

    v.debug = max( abs(coordinates.x-.5), abs(coordinates.y-.5) );

    v.life = 1;
 

 }

 v.life  -= .01 * (hash11( float(pID * 121)  )+ .3);
      

        
       //v.pos.x = sin(sID);
       //v.pos.y = cos(sID);
       // v.pos.z = sin(sID);


        _VertBuffer[sID] = v;
    }

}
